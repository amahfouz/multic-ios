//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: MinimaxMulticMoveAlgo.java
//
//  Created by amahfouz on 6/4/14.
//

#include "Four.h"
#include "Move.h"
#include "MoveIterator.h"
#include "MulticLog.h"
#include "MutableGameState.h"
#include "Player.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Integer.h"

#import "MinimaxMulticMoveAlgo.h"

@implementation MMCMinimaxMulticMoveAlgo

- (id)initWithInt:(int)maxDepth
 withMMUMulticLog:(id<MMUMulticLog>)log {
  if (self = [super init]) {
    if (log == nil) @throw [[JavaLangIllegalArgumentException alloc] init];
    if (maxDepth > MMCMinimaxMulticMoveAlgo_MAX_MAX_DEPTH) @throw [[JavaLangIllegalArgumentException alloc] init];
    self->maxDepth_ = maxDepth;
    self->log_ = log;
  }
  return self;
}

- (id<MMCMove>)findNextMoveWithMMCMutableGameState:(MMCMutableGameState *)gameState {
  self->gameState_ = gameState;
  self->moveToMake_ = nil;
  [self evalNodeWithInt:maxDepth_ withBoolean:YES];
  return moveToMake_;
}

- (int)evalNodeWithInt:(int)remainingDepth
           withBoolean:(BOOL)isMaximizing {
  MMCPlayerEnum *player = [((MMCMutableGameState *) nil_chk(gameState_)) getWinnerIfAny];
  if (player != nil) return [self addDepthToValueWithInt:[player valueOfFour] withInt:remainingDepth];
  if (remainingDepth == 0) return [self addDepthToValueWithInt:[gameState_ evalBoardState] withInt:remainingDepth];
  MMCMoveIterator *iter = [[MMCMoveIterator alloc] initWithMMCMutableGameState:gameState_];
  if (![iter hasNext]) return 0;
  int bestOutcome = isMaximizing ? JavaLangInteger_MIN_VALUE : JavaLangInteger_MAX_VALUE;
  MMCMove_Mutable *bestMove = [[MMCMove_Mutable alloc] init];
  MMCMove_Mutable *mutableMove = [[MMCMove_Mutable alloc] init];
  while ([iter hasNext]) {
    [iter getNextWithMMCMove_Mutable:mutableMove];
    MMCMutableGameState_Memento *undoInfo = [gameState_ makeMoveWithMMCMove:mutableMove];
    int val = [self evalNodeWithInt:remainingDepth - 1 withBoolean:!isMaximizing];
    [gameState_ applyUndoWithMMCMutableGameState_Memento:undoInfo];
    if ((isMaximizing && (val > bestOutcome)) || ((!isMaximizing) && (val < bestOutcome))) {
      bestOutcome = val;
      [mutableMove copyIntoWithMMCMove_Mutable:bestMove];
    }
  }
  if (remainingDepth == maxDepth_) moveToMake_ = [bestMove toImmutable];
  return bestOutcome;
}

- (int)addDepthToValueWithInt:(int)nodeValue
                      withInt:(int)remainingDepth {
  if (nodeValue == MMCFour_VALUE_WIN) return nodeValue + remainingDepth;
  if (nodeValue == -MMCFour_VALUE_WIN) return nodeValue - remainingDepth;
  return nodeValue;
}

- (void)copyAllFieldsTo:(MMCMinimaxMulticMoveAlgo *)other {
  [super copyAllFieldsTo:other];
  other->gameState_ = gameState_;
  other->log_ = log_;
  other->maxDepth_ = maxDepth_;
  other->moveToMake_ = moveToMake_;
}

+ (J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { "initWithInt:withMMUMulticLog:", "MinimaxMulticMoveAlgo", NULL, 0x1, NULL },
    { "findNextMoveWithMMCMutableGameState:", "findNextMove", "Lcom.mahfouz.multic.core.Move;", 0x1, NULL },
    { "evalNodeWithInt:withBoolean:", "evalNode", "I", 0x2, NULL },
    { "addDepthToValueWithInt:withInt:", "addDepthToValue", "I", 0x2, NULL },
  };
  static J2ObjcFieldInfo fields[] = {
    { "MAX_MAX_DEPTH_", NULL, 0x1a, "I", NULL, .constantValue.asInt = MMCMinimaxMulticMoveAlgo_MAX_MAX_DEPTH },
    { "maxDepth_", NULL, 0x12, "I", NULL,  },
    { "log_", NULL, 0x12, "Lcom.mahfouz.multic.util.MulticLog;", NULL,  },
    { "gameState_", NULL, 0x2, "Lcom.mahfouz.multic.core.MutableGameState;", NULL,  },
    { "moveToMake_", NULL, 0x2, "Lcom.mahfouz.multic.core.Move$Immutable;", NULL,  },
  };
  static J2ObjcClassInfo _MMCMinimaxMulticMoveAlgo = { "MinimaxMulticMoveAlgo", "com.mahfouz.multic.core", NULL, 0x11, 4, methods, 5, fields, 0, NULL};
  return &_MMCMinimaxMulticMoveAlgo;
}

@end
